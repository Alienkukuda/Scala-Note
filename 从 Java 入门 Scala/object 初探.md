##一.特性

在文章开始之前首先要先提一个问题，object是什么，是对象还是类，可能你会信誓旦旦地说是对象，毕竟object字面翻译过来就是对象。在我看来，他是对象没错，但是不全面。要确定这一点，明白object的特性是很有必要的。

我们可以拿它和class作比较，object本质上拥有类的所有特性，可以继承另一个超类，实现接口，并像传递类的实例一样传递，但是object不能提供构造函数参数，无法使用new运算符创建实例。其仅仅定义了一个单例实例，而类可以有多个实例；另一个特性，Object提供与Java中的静态方法和字段相同的效果。用一句话来概括，object关键字创建了**隐式定义的类的单例对象**，它可用于保存与某些类的实例无关的静态成员。

##二.回归常态

由于在scala中没有static关键词，所以对于一个class来说，在被实例化之前其内部成员变量以及方法都是无法访问的，这也就意味着class中的main方法也就失去了效果。因此，scala采用object来实现功能，object内部的所有成员变量和方法默认都是static，这在下面会详细讲到。

那么有人会问，为什么会删除static关键字呢？原因是静态不属于对象，它不能被继承，不参与多态。简单来说，静态不是面向对象的。scala作为一门函数式编程语言，是完全面向对象的，而static更像是一种先前遗留的产物。起初在设计java时，程序开发人员认为在任何地方都没必要把静态描述成面向对象的，但事实上，在java中，对象可是认为是一种常态，而static恰好打破了这个常态，在我个人理解看来这是不规范的。的确，单个对象允许以一种非常简洁的方式访问static属性以及方法，但当你想让其具备继承行为，静态并不会给予你任何帮助。object的诞生可以说为了将静态回归常态，让代码更加的规范。

##三.静态属性

#### 3.1.静态成员的容器

我们先来用代码验证下object的单例性。

```scala
object test {
  var a = 1
  def main(args : Array[String]){
    var x = test.a
    var y = test.a
    println("x eq y : " + x.equals(y))
  }
}
```

在如上示例中，通过两次访问object中a变量的比较来判断其是否为同一个对象，事实证明确实如此，输出结果如下：

```scala
a eq a1 : true
```

在scala中，大多数情况下，我们会用object来保存方法和变量，而无需先实例化某个类的实例，这种用法与java中的static密切想关。

```scala
object O {
  def add(i: Int): Int = i + 1
}
```

像这样初始化后，你就可以直接调用`O.add(1)`，但如果o是一个类，那上面的调用明显是不符合实际的。这时候，由于`add`是类的某个成员，那么你需要先创建一个实例。

```scala
class O() {
  def add(i: Int): Int = i + 1
}

val o = new O()
o.add(1)
```

这显得很冗余，毕竟`add`方法的调用并不依赖于你实例中的数据。

#### 3.2.特殊命名实例

除上面之外，你还可以将`object`自身用作类或特质的一些特殊实例。在执行此操作时，你的对象需要扩展`trait`，以便成为它的子类的实例。

看以下代码：

```scala
object A extends B with C {
  ...
}
```

该`object`对象首先声明，同时继承匿名（无法访问）类`B`和`C`，并定义了这种名为`A`类的一个实例。

这个`A`可以被传到要用到`B`或`C`类型的对象的方法中使用。

#### 3.3.方法/伴生对象

首先来看一段代码

```scala
new Array[Person](new Person("Rhyme"),new Person("Captain"))
Array[Person](Person("Rhyme"),Person("Captain"))
```

你觉得哪种形式更加简洁直观呢？第一种方式这里不再解释，第二种方式，你会发现，我们省去了`new`关键字。

我们先不管具体的语言特性，单从代码本身来看，你会更倾向于哪一种？

很明显，我会选择第二种省去`new`关键字的方式。原因很简单：更加自然，更加简洁。首先，作为同行，想必`new`关键字我们再熟悉不过了。敲了它不下一万遍有没有！敲了这么多，你就没有感觉过**烦**吗？

其实**烦**这个字很关键，一旦你写某段代码写得烦了，就说明这段代码本身就是存在题的。然而如果你觉得它并没有什么，那只能说明你已经麻木了，作为一个好的程序员，不应该麻木，我们要想法设法，写**最关键的代码**。

首先作为一个全民公认的`new`操作，为什么我不可以将`new`这个关键字从类名前面移去呢？注意我们关注的应该是**最关键的代码**。`new`关键字对我来说，已经是再熟悉不过的东西了，它对我已经没有价值了，就让他默认存在就好了，我不需要再看到它！

而这种可以帮你省去`new`操作的语言特性我们就可以使用`apply`方法来实现。

我们通常会在伴生对象中定义一个`apply()`方法，例如如下代码：

```scala
class Person(name: String) {
}

object Person {
  def apply(name: String):Person = new Person(name)
}
```

`apply`方法将为我们返回一个「伴生类」的对象。当我门在执行`Person("Rhyme")`的时候，默认就会调用「伴生对象」中的`apply()`放回，并为你返回一个创建好的对象。如果你不想使用`apply()`方法，自己定义一个更适合自己的工厂方法也是一个不错的选择。

```scala
class Person(name: String) {
}

object Person {
  def createPerson(name:String):Person = {
    new Person(name)
  }
}
```

